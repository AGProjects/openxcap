# Copyright (C) 2007 AG Projects.
#

"""HTTP handling for the XCAP server"""

import os

from application.configuration import readSettings, ConfigSection
from application import log
from gnutls.interfaces.twisted import X509Credentials

from zope.interface import implements

from twisted.internet import reactor
from twisted.web2 import channel, resource, http, responsecode, server
from twisted.cred.portal import Portal
from twisted.cred import credentials, portal, checkers, error as credError
from twisted.web2.auth import digest, basic, wrapper

from xcap.resource import XCAPDocument, XCAPElement
from xcap import authentication
from xcap.applications import getApplicationForURI
from xcap.uri import XCAPUri
from xcap.tls import Certificate, PrivateKey
from xcap import __version__ as version

server.VERSION = "OpenXCAP/%s" % version


class AuthenticationConfig(ConfigSection):
    type = 'basic'
    default_realm = 'example.com'

class ServerConfig(ConfigSection):
    port = 8000
    address = '0.0.0.0'
    tls = False

class TLSConfig(ConfigSection):
    _dataTypes = {'certificate': Certificate, 'private_key': PrivateKey}
    certificate = None
    private_key = None

## We use this to overwrite some of the settings above on a local basis if needed
readSettings('Authentication', AuthenticationConfig)
readSettings('Server', ServerConfig)
readSettings('TLS', TLSConfig)


def log_request(request):
    uri = request.xcap_uri
    user_agent = request.headers.getHeader('user-agent', 'unknown')
    msg = "%s from %s %s %s - client: %s" % (uri.user, request.remoteAddr.host,
                                                request.method, uri, user_agent)
    log.msg(msg)

class XCAPRoot(resource.Resource):
    addSlash = True

    def allowedMethods(self):
        return ('GET', 'PUT', 'DELETE', 'POST')

    def locateChild(self, request, segments):
        ## don't use object traversal
        return self, server.StopTraversal

    def renderHTTP(self, request):
        ## forward the request to the appropiate XCAP resource, based on the 
        ## XCAP request URI
        xcap_uri = request.xcap_uri
        application = getApplicationForURI(xcap_uri)
        log_request(request)
        if not application:
            return http.Response(responsecode.NOT_FOUND, stream="Application not supported")
        if not xcap_uri.node_selector: ## the request is for an XCAP document
            resource = XCAPDocument(xcap_uri, application)
            return resource.renderHTTP(request)
        else:
            if xcap_uri.node_selector.terminal_selector[0] == '@': ## the request is for an attribute
                resource = XCAPAttribute(xcap_uri, application)
            else: ## the request is for an element
                resource = XCAPElement(xcap_uri, application)
        return resource.renderHTTP(request)


class XCAPServer:
    
    def __init__(self):
        portal = Portal(authentication.XCAPAuthRealm())
        checker = authentication.DatabasePasswordChecker()
        portal.registerChecker(checker)
        
        if AuthenticationConfig.type == 'basic':
            credential_factory = basic.BasicCredentialFactory(AuthenticationConfig.default_realm)
        else:
            credential_factory = digest.DigestCredentialFactory('MD5', AuthenticationConfig.default_realm)

        root = authentication.XCAPAuthResource(XCAPRoot(),
                                            (credential_factory,),
                                            portal, (authentication.IXCAPUser,))
        self.site = server.Site(root)

    def start(self):
        channel.HTTPFactory.noisy = True
        if ServerConfig.tls:
            cert, pKey = TLSConfig.certificate, TLSConfig.private_key
            if cert is None or pKey is None:
                log.fatal("the SSL certificates or the private key could not be loaded")
            credentials = X509Credentials(cert, pKey)
            reactor.listenTLS(ServerConfig.port, channel.HTTPFactory(self.site), credentials, interface=ServerConfig.address)
            print 'TLS started'
        else:        
            reactor.listenTCP(ServerConfig.port, channel.HTTPFactory(self.site), interface=ServerConfig.address)
        reactor.run()


#Etag header


#The Last-Modified header suffers the same problems as the Expires header, and thus 
#was replaced in HTTP 1.1 with the Etag header. An Etag is a string that uniquely 
#identifies a resource, they should be generated by the server in a way as to change
#whenever the resource does, a common Etag value is the MD5 hash of the resource or 
#of the resources URL and its modified date/time stamp.

#When a client sends a "If-None-Match" request header, the Etag value in that header
#should be compared to the resource and if it matches, a 304 Not Modified response sent.
